input {
    stdin { }

    file {
        path => "${PWD}/data/movies_metadata.csv"
        start_position => "beginning"
        sincedb_path => "/dev/null"
        codec => multiline {
            pattern => "^(False|True),"
            negate => true
            what => "previous"
            auto_flush_interval => 1
        }
    }
}
filter {
    csv {
        columns => [ "adult","belongs_to_collection","budget","genres","homepage","id","imdb_id","original_language","original_title","overview","popularity","poster_path","production_companies","production_countries","release_date","revenue","runtime","spoken_languages","status","tagline","title","video","vote_average","vote_count" ]
        skip_header => true
    }

    mutate {
        gsub => [
            "belongs_to_collection", ": None", ": null",
            "belongs_to_collection", "((?<={)\s*\'|(?<=,)\s*\'|\'\s*(?=:)|(?<=:)\s*\'|\'\s*(?=,)|\'\s*(?=}))", '"'
        ]
    }
    json {
        source => "belongs_to_collection"
        target => "belongs_to_collection"
    }

    mutate {
        gsub => [
            "production_companies", 'Orlenok",', 'Orlenok"',
            "production_companies", "\\xa0", "",
            "production_companies", ': "', ": '",
            "production_companies", '",', "',",
            "production_companies", '"', '\\"',
            "production_companies", "((?<={)\s*\'|(?<=,)\s*\'|\'\s*(?=:)|(?<=:)\s*\'|\'\s*(?=,)|\'\s*(?=}))", '"'
        ]
    }
    json {
        source => "production_companies"
        target => "production_companies"
    }

    mutate {
        gsub => [
            "production_countries", "((?<={)\s*\'|(?<=,)\s*\'|\'\s*(?=:)|(?<=:)\s*\'|\'\s*(?=,)|\'\s*(?=}))", '"'
        ]
    }
    json {
        source => "production_countries"
        target => "production_countries"
    }
    translate {
        dictionary_path => "${PWD}/data/countries_geo.csv"
        iterate_on => "[production_countries]"
        field => "[iso_3166_1]"
        destination => "[location]"
    }
    ruby {
        code => '
            if event.include?("[production_countries]") and event.get("[production_countries]").kind_of?(Array)
                production_countries_name_list = []
                production_countries_location_list = []
                event.get("[production_countries]").each_with_index do |v, i|
                    production_countries_name_list.push(v["name"])
                    production_countries_location_list.push(v["location"])
                end
                event.set("[production_countries_name_list]", production_countries_name_list)
                event.set("[production_countries_location_list]", production_countries_location_list)
            end
        '
    }

    mutate {
        gsub => [
            "genres", "((?<={)\s*\'|(?<=,)\s*\'|\'\s*(?=:)|(?<=:)\s*\'|\'\s*(?=,)|\'\s*(?=}))", '"'
        ]
    }
    json {
        source => "genres"
        target => "genres"
    }
    ruby {
        code => '
            if event.include?("[genres]") and event.get("[genres]").kind_of?(Array)
                genres_list = []
                event.get("[genres]").each_with_index do |v, i|
                    genres_list.push(v["name"])
                end
                event.set("[genres_list]", genres_list)
            end
        '
    }

    mutate {
        gsub => [
            "spoken_languages", "Lietuvi\\x9akai", "Lithuanian",
            "spoken_languages", "((?<={)\s*\'|(?<=,)\s*\'|\'\s*(?=:)|(?<=:)\s*\'|\'\s*(?=,)|\'\s*(?=}))", '"'
        ]
    }
    json {
        source => "spoken_languages"
        target => "spoken_languages"
    }

    mutate {
        gsub => [
            "video", "False", "false",
            "video", "True", "true",
            "adult", "False", "false",
            "adult", "True", "true"
        ]
    }

    date {
        match => [ "release_date", "yyyy-MM-dd" ]
    }

    mutate {
        convert => {
            "adult" => "boolean"
            "id" => "integer"
            "vote_count" => "integer"
            "budget" => "float"
            "vote_average" => "float"
            "popularity" => "float"
            "revenue" => "float"
            "runtime" => "float"
        }
    }

    mutate {
        remove_field => [ "message", "path", "host" ]
    }
}
output {
    stdout { codec => dots }

    #stdout { codec => rubydebug }

    elasticsearch {
        hosts => ["localhost:9200"]
        index => "movies"
		document_id => "%{id}"
    }
}
